This is a mirror of http://www.vim.org/scripts/script.php?script_id=3552

Given a pattern string and a set of values, replaces the parameters in the pattern with the specified values. The values may be either a Dictionary or a List,
and the expansion can be done recursively or just once, as in the example below.

Example (note the 1 at the end, indicating recursion as fullName is defined as fName and lName):

echo MessageFormatter#FormatMessage( "My name is {fullName} (first name '{fName}', last name '{lName}').", { 'fName': 'john', 'lName': 'smith', 'fullName': '{t_fName} {t_lName}' }, 1 )

Echoes (note how fullName gets further expanded): My name is John Smith (first name 'john', last name 'smith').

Same example, with a 0 at the end (or nothing, as the recursion parameter is optional):

Echoes (note how fullName is not expanded recursively): My name is {t_fName} {t_lName} (first name 'john', last name 'smith').

Same (recursive) example using a List instead of a Dictionary:

echo MessageFormatter#FormatMessage( "My name is {2} (first name '{0}', last name '{1}').", [ 'john', 'smith', '{t_0} {t_1}' ], 1 )

Note: To use an actual '{' or '}', escape it with a backslash.

Observe how some of the parameters start with t_ before the actual name. There are a number of formatting parameters:

a (optional): as is
l: lower case
u: upper case
f: first letter capitalized only
t: title case the entire string
c: camel case: converts 'an interesting phrase' to 'anInterestingPhrase'
C: constant mode: converts 'anInterestingPhrase' or 'an interesting phrase' to 'AN_INTERESTING_PHRASE'
w: from 'anInterestingPhrase' or 'AN_INTERESTING_PHRASE' to 'an intersting phrase'

Both the parameters AND the formatting directives are case-sensitive. If multiple formatting parameters are specified, they will be applied in the order
supplied. For example {c_val} where 'val' is 'some variable' results in 'someVariable'. However, {cf_val} gives 'SomeVariable' because the following 'f'
capitalizes the first letter of the result from 'c' (camel case).

Version 1.5:

Added a cache so repeated expansions of the same variable can be looked up rather than computed (potentially much faster, especially when recursion is on).

Version 2.0:

Added new formatting modifier:

e: Escapes out quotation marks (") and backslashes, leaving the value suitable for placing in quotes. For example, {e_fName} where fName is Jo\nhn results in
Jo\\nhn.

If an expansion parameter starts with "eval ", the rest of the value is evaluated and the return value used as the actual parameter value. If recursion is on,
that value may contain further parameters.

Example:

echo MessageFormatter#FormatMessage('public static final {type} {C_variable} = {value};', {'type':'eval input("Type for {variable}: ", "String")', 'variable':'eval input("Variable name: ")', 'value':'eval input("Value: ", "\"{C_variable}\"")'}, 1)

Bear in mind that 'type' and 'value' both use the parameter 'variable'. If 'variable' were to refer to either of these, you'd have circular recursion. There
is no check in place for that; you'd just end up with a stack overflow.

Note, also, that the expression is evaluated only once. After that, its value is stored on the cache--this allows eval parameters to refer to other eval
parameters (only useful if recursion is on).

Version 3.0:

Fairly big changes. RELIES UPON MY GetVar.vim (http://vim.sourceforge.net/scripts/script.php?script_id=353) script now.

New formatting parameter:

n: non-displayed value. The return value is suppressed--useful for adding a value to the cache to be used later.

New function:

FormatContainedMessage: Works like MessageFormatter#FormatMessage except that it's always recursive and that its original text string can contain default
values for the parameters (so the second parameter is optional); for example,

echo FormatContainedMessage( 'My first name is {John::first name} and my full name is {{first name} Smith::full name}; how many letters in {u_full name}?' )

Gives

My first name is John and my full name is John Smith; how many letters in JOHN SMITH?

This can be recursive (look at "full name" and can contain more default values, such as starting things with "eval " to have them evaluated. To force an empty
string, use {::name} (just {name} assumes that the value will be specified elsewhere).

Some commands and functions to allow the reuse of parameters:

FormatMessage: takes a string and returns a formatted value, using previously specified parameters through:

Formatmessage and Formatmessagerecursive: command versions that call FormatMessage; process whatever is typed.

Addformatparameter: adds whatever you type as is (may be recursive) as a list parameter.

Adddictionaryformatparameter: adds whatever you type as is, with the first word being the name of the parameter and the rest of the arguments the value.

Showparameters: Displays the list of specified parameters.

Resetformatparameters: Removes the list of parameters currently specified.

Version 3.5:

Added a command version of FormatContainedMessage called Formatcontainedmessage that passes everything on the command-line as-is to the function and echoes
the result.

Added a new default value type:

If the default value for for a parameter (passed to FormatContainedMessage) is "ask", it defaults to asking the user (via an input). If the value is anything
followed by "ask", it will use that as the default value for the input.

Examples:
" 
{ask::first name} will display an input prompt asking, "Enter value for first name".

{ask Smith::last name} will display an input prompt asking "Enter value for last name", but will offer "Smith" as the default value (just press enter to
accept).

As always, recursion is supported, so

My name is {ask {ask John::first name} {ask Smith::last name}::full name} (family name is {last name}).

Will first prompt for the first name, offering "John" as the default, then for the last name, offering "Smith" as the default and, finally, for the full name,
offering the entered first and last name together as the default ("John Smith" by default) before displaying the formatted message.

